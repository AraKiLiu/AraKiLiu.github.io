<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on 工程師的呢喃</title>
    <link>https://arakiliu.github.io/categories/python/</link>
    <description>Recent content in Python on 工程師的呢喃</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-th</language>
    <lastBuildDate>Tue, 29 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://arakiliu.github.io/categories/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>classmethod &amp; staticmethod</title>
      <link>https://arakiliu.github.io/2020/12/28/classmethod_and_staticmethod/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://arakiliu.github.io/2020/12/28/classmethod_and_staticmethod/</guid>
      <description>staticmethod 在使用時，不需要用到self自己實例本身時，就可以用staticmethod。 class Car: def __inti__(self, exterior): self.exterior = exterior def move(self): self.start_engine() print(&amp;#39;move is method called.) @staticmethod def start_engine() print(&amp;#39;static method&amp;#39;) Car.start_engine() # &amp;#39;static method&amp;#39; classmethod 要是不想創</description>
    </item>
    
    <item>
      <title>Property 裝飾器</title>
      <link>https://arakiliu.github.io/2020/12/28/PropertyDecorator/</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://arakiliu.github.io/2020/12/28/PropertyDecorator/</guid>
      <description>封裝 encapsulation 封裝 encapsulation：在物件導向中，封裝就是不讓外部使用者直接取用物件中的內容，只能用方法來修改。 class Car(object): def __init__(self, wheel): self._wheel = wheel def get_wheel(self): return self._wheel def</description>
    </item>
    
    <item>
      <title>閉包 Closure</title>
      <link>https://arakiliu.github.io/2020/12/25/Closure/</link>
      <pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://arakiliu.github.io/2020/12/25/Closure/</guid>
      <description>string =&amp;#39;global&amp;#39; def assignment(): string = &amp;#39;Enclosd&amp;#39; # Enclosd def inner(): print(string) #local return inner func = assignment() print(func) # &amp;lt;function assignment.&amp;lt;locals&amp;gt;.inner at 0x000001AED30AAF28&amp;gt; func() # Enclosd print(string) # global 在最後的print(string)中，不會因為呼叫了func( )而使得最後的輸出</description>
    </item>
    
    <item>
      <title>裝飾器 Decorator</title>
      <link>https://arakiliu.github.io/2020/12/24/Decorator/</link>
      <pubDate>Thu, 24 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://arakiliu.github.io/2020/12/24/Decorator/</guid>
      <description>裝飾器 Decorator 加工修飾加上一些我們要的功能 print_fun_name(func) 會把傳入的 function 再利用一個我們命為 wrapper( )的內部function做加工，然後在用 return wrapper 吐出修飾過的 function wrappe</description>
    </item>
    
    <item>
      <title>抽象類別 Abstract Class</title>
      <link>https://arakiliu.github.io/2020/12/23/abstract-class/</link>
      <pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://arakiliu.github.io/2020/12/23/abstract-class/</guid>
      <description>抽象類別 Abstract Class 抽象類別：不做實例的類別，給其他類別繼承用的基底類別base class。一個類別中有一個或一個以上的abstract method</description>
    </item>
    
    <item>
      <title>繼承(2)</title>
      <link>https://arakiliu.github.io/2020/12/21/inheritance/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://arakiliu.github.io/2020/12/21/inheritance/</guid>
      <description>python中，所有東西都是物件，每個物件都有他自己的型別(type)。 # parent class / base class class Transportation: def __init__(self): self.exterior = &amp;#34;white&amp;#34; def drive(self): print(&amp;#34;drive method is called.&amp;#34;) # child class / deroved class class Car(Transportation): def move(self): print(&amp;#34;move is method called.&amp;#34;) #</description>
    </item>
    
    <item>
      <title>繼承(1)</title>
      <link>https://arakiliu.github.io/2020/12/17/inheritance/</link>
      <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://arakiliu.github.io/2020/12/17/inheritance/</guid>
      <description>繼承 (Inheritance) 繼承(Inheritance)：父類別跟子類別的階層關係，子類別會有父類別的屬性與方法。 在程式中將各類別共用屬性與方法方在一個獨立類別</description>
    </item>
    
    <item>
      <title>雙底線方法</title>
      <link>https://arakiliu.github.io/2020/12/16/dunder_methods/</link>
      <pubDate>Wed, 16 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://arakiliu.github.io/2020/12/16/dunder_methods/</guid>
      <description>new 與 init class Product: # __new__ 是一个 static method, args 是傳入的参数，為tuple, kwargs為dict def __new__(cls, *args, **kwargs): print(&amp;#39;new method&amp;#39;, args, kwargs) return object.__new__(MyClass) def __init__(self, name, price): self.name = name self.price = price print(&amp;#39;init method&amp;#39;) # 创建一個MyCla</description>
    </item>
    
    <item>
      <title>底線的各種情況與涵義</title>
      <link>https://arakiliu.github.io/2020/12/15/underscore/</link>
      <pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://arakiliu.github.io/2020/12/15/underscore/</guid>
      <description>只有一個 底線：程式中不重要的變數，這可以讓以後別人或自己在觀看程式碼時，馬上知道這變數不重要。 for _ in range(10): print(&amp;#39;Hi&amp;#39;) name, _ = &amp;#39;name$age&amp;#39;.split(&amp;#39;$&amp;#39;) 名稱前有一個底線 ：要是希望變</description>
    </item>
    
    <item>
      <title>Scope</title>
      <link>https://arakiliu.github.io/2020/12/14/Scope/</link>
      <pubDate>Mon, 14 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://arakiliu.github.io/2020/12/14/Scope/</guid>
      <description>查找namespace的順序與權限 查找順序 Local -&amp;gt; Enclosed -&amp;gt; Global -&amp;gt; Built-in 低層不能改變高層的值，只能讀取。 x = 1 def outer(): x = 10 outer() print(x) # 1 因為Local沒有x所以會往</description>
    </item>
    
    <item>
      <title>Namespace</title>
      <link>https://arakiliu.github.io/2020/12/11/Namespace/</link>
      <pubDate>Fri, 11 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://arakiliu.github.io/2020/12/11/Namespace/</guid>
      <description>Python中的命名空間是一個字典 (dictionary） ，它的key就是變數名稱，它的值就是那些變數的值。 x = 2 def g(): x = 4 Python中有</description>
    </item>
    
    <item>
      <title>參數的傳遞模式</title>
      <link>https://arakiliu.github.io/2020/12/10/pass-by-reference/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://arakiliu.github.io/2020/12/10/pass-by-reference/</guid>
      <description>variable 跟 value 談起 variable 與其 儲存(參考)的 value (object) 是兩個完全不同的東西: variable 是一個抽象的概念，value 是一個實際存在的資料 variable 不是其對應的 value，vair</description>
    </item>
    
  </channel>
</rss>
